<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minecraft Block Command Previewer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/GLTFExporter.js"></script>
    <style>
        body { margin: 0; background-color: #020617; color: white; font-family: ui-sans-serif, system-ui, sans-serif; display: flex; height: 100vh; overflow: hidden; }
        
        .sidebar {
            width: 33.33%;
            border-right: 1px solid #1e293b;
            display: flex;
            flex-direction: column;
            padding: 20px;
            background: #0f172a;
            z-index: 10;
        }

        .main-content {
            width: 66.66%;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        #container {
            flex: 1;
            cursor: grab;
            outline: none;
        }
        #container:active { cursor: grabbing; }

        .editor-area {
            flex: 1;
            background: #1e293b;
            color: #e2e8f0;
            border: 1px solid #334155;
            border-radius: 8px;
            padding: 15px;
            font-family: monospace;
            resize: none;
            outline: none;
            margin-top: 10px;
            font-size: 13px;
            line-height: 1.5;
        }

        .bottom-controls {
            height: 70px;
            background: #0f172a;
            border-top: 1px solid #1e293b;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            padding: 0 10px;
        }

        .btn {
            background: #1e293b;
            color: white;
            padding: 6px 12px;
            border-radius: 6px;
            border: 1px solid #475569;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 13px;
            white-space: nowrap;
        }
        .btn:hover { background: #334155; border-color: #3b82f6; }
        .btn-run { background: #10b981; border-color: #34d399; font-weight: bold; }

        #loading-screen {
            position: absolute;
            inset: 0;
            background: rgba(2, 6, 23, 0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        /* Modal for schematic info */
        #modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        .modal-box {
            background: #1e293b;
            padding: 24px;
            border-radius: 12px;
            max-width: 450px;
            border: 1px solid #3b82f6;
            text-align: center;
        }

        /* Export Menu Styles */
        .export-container {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
        }
        .export-menu {
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 8px;
            background: #1e293b;
            border: 1px solid #334155;
            border-radius: 8px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5);
            display: none;
            min-width: 220px;
            overflow: hidden;
        }
        .export-menu.show { display: block; }
        .export-item {
            padding: 12px 15px;
            cursor: pointer;
            transition: background 0.2s;
            display: flex;
            flex-direction: column;
            border-bottom: 1px solid #334155;
        }
        .export-item:last-child { border-bottom: none; }
        .export-item:hover { background: #334155; }
        .export-item span:last-child { font-size: 10px; color: #94a3b8; }

        .content-hidden { display: none; }
        .arrow-icon { transition: transform 0.3s; }
        
        #langSelect {
            background: #1e293b;
            color: white;
            border: 1px solid #334155;
            padding: 2px 6px;
            border-radius: 4px;
            outline: none;
            cursor: pointer;
            font-size: 12px;
        }

        #recording-dot {
            display: none;
            width: 12px;
            height: 12px;
            background: #ef4444;
            border-radius: 50%;
            margin-right: 8px;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.2); }
            100% { opacity: 1; transform: scale(1); }
        }
    </style>
</head>
<body>

    <div class="sidebar">
        <div class="flex justify-between items-center mb-1">
            <h2 class="text-xl font-bold" data-i18n="editorTitle">Command Editor</h2>
            <select id="langSelect" onchange="changeLanguage(this.value)">
                <option value="en">English</option>
                <option value="hu" selected>Magyar</option>
            </select>
        </div>

        <!-- CREDITS SECTION -->
        <div class="text-[10px] text-slate-500 mb-2 flex flex-col gap-0.5 border-b border-slate-800 pb-2">
            <div>Idea: <span class="text-slate-300">peter240110</span></div>
            <div>Special thanks: <a href="https://gemini.google.com" target="_blank" class="text-blue-500 hover:underline">Gemini</a></div>
        </div>

        <p class="text-[10px] text-slate-400 mb-2" data-i18n="exampleText">P√©ld√°k: /setblock, /fill, /clone x1 y1 z1 x2 y2 z2 dx dy dz [m√≥d]</p>
        <textarea id="commandEditor" class="editor-area" spellcheck="false">/fill 0 0 0 1 1 1 minecraft:redstone_block
/fill 0 2 0 1 2 1 minecraft:glass
/clone 0 0 0 1 2 1 3 0 0 masked</textarea>
        
        <div class="slider-container mt-4 bg-slate-800/50 p-3 rounded-lg border border-slate-700">
            <div class="flex justify-between text-xs mb-1">
                <span><span data-i18n="gridSizeLabel">R√°csm√©ret</span>: <span id="gridVal">21</span>x21</span>
            </div>
            <input type="range" id="gridSlider" min="21" max="101" step="2" value="21" class="w-full cursor-pointer" oninput="updateGridSize(this.value)">
        </div>

        <div class="mt-4 flex flex-col gap-2">
            <button class="btn btn-run py-3" onclick="parseAndRunCommands()" data-i18n="runBtn">Parancsok futtat√°sa</button>
            <button class="btn bg-red-900/30 border-red-500/50 hover:bg-red-800" onclick="clearAllBlocks()" data-i18n="clearBtn">√ñsszes t√∂rl√©se</button>
        </div>
        
        <div class="mt-4 p-3 bg-slate-800/50 rounded-lg border border-slate-700">
            <div class="flex items-center justify-between cursor-pointer" onclick="toggleBlockList()">
                <h3 class="text-sm font-bold text-blue-400" data-i18n="availableBlocksTitle">Haszn√°lhat√≥ blokkok</h3>
                <svg id="listArrow" class="arrow-icon w-4 h-4 text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path d="M19 9l-7 7-7-7" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg>
            </div>
            <div id="blockListWrapper" class="content-hidden mt-2">
                <div class="max-h-[150px] overflow-y-auto">
                    <ul class="text-xs space-y-1 text-slate-300" id="availableBlocksList"></ul>
                </div>
            </div>
        </div>
    </div>

    <div class="main-content">
        <div class="export-container">
            <button class="btn bg-blue-600 hover:bg-blue-500 border-blue-400 flex items-center gap-2" onclick="toggleExportMenu(event)">
                <div id="recording-dot"></div>
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path></svg>
                <span>Export</span>
            </button>
            <div id="exportMenu" class="export-menu">
                <div class="export-item" onclick="exportSchematic()">
                    <span class="font-bold text-sm text-emerald-400" data-i18n="expSchemTitle">Minecraft Schematic</span>
                    <span data-i18n="expSchemDesc">(.schem) - Vil√°gba t√∂lthet≈ë</span>
                </div>
                <div class="export-item" onclick="exportGLB()">
                    <span class="font-bold text-sm text-blue-400" data-i18n="expModelTitle">3D Modell</span>
                    <span data-i18n="expModelDesc">(.glb) - Blender / Preview</span>
                </div>
                <div class="export-item" onclick="takeScreenshot()">
                    <span class="font-bold text-sm text-purple-400" data-i18n="expImgTitle">K√©p ment√©se</span>
                    <span data-i18n="expImgDesc">(.png) - Pillanatk√©p</span>
                </div>
                <div class="export-item" onclick="recordVideo()">
                    <span class="font-bold text-sm text-red-400" data-i18n="expVidTitle">Vide√≥ k√©sz√≠t√©se</span>
                    <span data-i18n="expVidDesc">(.webm) - 360¬∞ k√∂rbefordul√°s</span>
                </div>
            </div>
        </div>

        <div id="loading-screen">
            <div class="text-xl font-bold mb-2" id="loading-title" data-i18n="loadingText">Blokkok √©p√≠t√©se...</div>
            <div id="loading-progress" class="text-sm text-slate-400">0 / 0</div>
        </div>

        <div id="modal-overlay">
            <div class="modal-box">
                <h3 class="text-emerald-400 font-bold text-lg mb-2">Export K√©sz!</h3>
                <p class="text-sm text-slate-300 mb-4" id="modal-text"></p>
                <div class="flex flex-col gap-2">
                    <a href="#" id="converter-link" target="_blank" class="text-blue-400 text-xs hover:underline bg-blue-900/20 p-2 rounded border border-blue-500/30">
                        üîó Konverter megnyit√°sa (Hamarosan...)
                    </a>
                    <button class="btn mt-2 bg-slate-700" onclick="closeModal()">Bez√°r√°s</button>
                </div>
            </div>
        </div>

        <div id="container" tabindex="0"></div>

        <div class="bottom-controls">
            <button class="btn" onclick="adjustZoom(-2)" data-i18n="zoomInBtn">K√∂zel√≠t√©s (+)</button>
            <button class="btn" onclick="adjustZoom(2)" data-i18n="zoomOutBtn">T√°vol√≠t√°s (-)</button>
            <button class="btn" onclick="toggleAutoRotate()" id="rotateBtn" data-i18n="startRotateBtn">Forgat√°s</button>
            <button class="btn bg-indigo-600 border-indigo-400" onclick="cycleCoordMode()" id="modeBtn">Koordin√°ta m√≥d: Tengelyek</button>
            <button class="btn" onclick="resetCamera()" data-i18n="resetBtn">Alaphelyzet</button>
        </div>
    </div>

    <script>
        const translations = {
            en: {
                editorTitle: "Command Editor",
                exampleText: "Examples: /setblock, /fill, /clone x1 y1 z1 x2 y2 z2 dx dy dz [mask]",
                gridSizeLabel: "Grid Size",
                runBtn: "Run Commands",
                clearBtn: "Clear All",
                availableBlocksTitle: "Available Blocks",
                loadingText: "Building blocks...",
                recordingText: "Recording video...",
                zoomInBtn: "Zoom In (+)",
                zoomOutBtn: "Zoom Out (-)",
                startRotateBtn: "Start Rotation",
                stopRotateBtn: "Stop Rotation",
                resetBtn: "Reset",
                coordModes: ["None", "Axes", "All"],
                coordPrefix: "Coord Mode: ",
                expSchemTitle: "Minecraft Schematic",
                expSchemDesc: "(.schem) - Ready for import",
                expModelTitle: "3D Model",
                expModelDesc: "(.glb) - Blender / Preview",
                expImgTitle: "Save Image",
                expImgDesc: "(.png) - Snapshot",
                expVidTitle: "Create Video",
                expVidDesc: "(.webm) - 360¬∞ turnaround",
                alertSchem: "The .schem file is in JSON format for now. You can convert it using our upcoming tool."
            },
            hu: {
                editorTitle: "Parancs Szerkeszt≈ë",
                exampleText: "P√©ld√°k: /setblock, /fill, /clone x1 y1 z1 x2 y2 z2 dx dy dz [m√≥d]",
                gridSizeLabel: "R√°csm√©ret",
                runBtn: "Parancsok futtat√°sa",
                clearBtn: "√ñsszes t√∂rl√©se",
                availableBlocksTitle: "Haszn√°lhat√≥ blokkok",
                loadingText: "Blokkok √©p√≠t√©se...",
                recordingText: "Vide√≥ r√∂gz√≠t√©se...",
                zoomInBtn: "K√∂zel√≠t√©s (+)",
                zoomOutBtn: "T√°vol√≠t√°s (-)",
                startRotateBtn: "Forgat√°s Ind√≠t√°sa",
                stopRotateBtn: "Forgat√°s Le√°ll√≠t√°sa",
                resetBtn: "Alaphelyzet",
                coordModes: ["Nincs", "Tengelyek", "Minden"],
                coordPrefix: "Koordin√°ta m√≥d: ",
                expSchemTitle: "Minecraft Schematic",
                expSchemDesc: "(.schem) - Vil√°gba t√∂lthet≈ë",
                expModelTitle: "3D Modell",
                expModelDesc: "(.glb) - Blender / Windows Preview",
                expImgTitle: "K√©p ment√©se",
                expImgDesc: "(.png) - Pillanatk√©p",
                expVidTitle: "Vide√≥ k√©sz√≠t√©se",
                expVidDesc: "(.webm) - 360¬∞ k√∂rbefordul√°s",
                alertSchem: "A .schem f√°jl egyel≈ëre JSON form√°tumban t√∂lt≈ëd√∂tt le. Haszn√°ld a konverter√ºnket a .schem-m√© alak√≠t√°shoz!"
            }
        };

        let currentLang = 'hu';
        let scene, camera, renderer;
        let isAutoRotating = false;
        let zoomDistance = 25;
        let coordMode = 1;
        let currentGridSize = 21;
        let gridHelper;
        let isListOpen = false;
        
        let targetRotationX = 0.5, targetRotationY = -0.5;
        let cameraTarget = new THREE.Vector3(0, 0, 0);
        
        const labelGroup = new THREE.Group();
        const blockGroup = new THREE.Group();
        const loader = new THREE.GLTFLoader();
        const modelCache = {};
        let worldData = {}; 

        const MODELS = {
            'minecraft:redstone_block': 'https://raw.githubusercontent.com/peter240110/Lit_Redstone_Lamp/main/Block_of_Redstone.glb',
            'minecraft:redstone_lamp': 'https://raw.githubusercontent.com/peter240110/Lit_Redstone_Lamp/main/Redstone_Lamp.glb',
            'minecraft:lit_redstone_lamp': 'https://raw.githubusercontent.com/peter240110/Lit_Redstone_Lamp/main/Lit_Redstone_Lamp.glb',
            'minecraft:glass': 'https://raw.githubusercontent.com/peter240110/Lit_Redstone_Lamp/main/Glass.glb',
            'minecraft:white_wool': 'https://raw.githubusercontent.com/peter240110/Lit_Redstone_Lamp/main/White_Wool.glb',
            'minecraft:redstone_repeater': 'https://raw.githubusercontent.com/peter240110/Lit_Redstone_Lamp/main/minecraft_redstone-repeater.glb',
            'minecraft:redstone_torch': 'https://raw.githubusercontent.com/peter240110/Lit_Redstone_Lamp/main/redstone-torch.glb',
            'minecraft:redstone_dust': 'https://raw.githubusercontent.com/peter240110/Lit_Redstone_Lamp/main/redstone_dust.glb',
            'minecraft:air': null
        };

        function toggleExportMenu(e) {
            e.stopPropagation();
            document.getElementById('exportMenu').classList.toggle('show');
        }

        function closeModal() {
            document.getElementById('modal-overlay').style.display = 'none';
        }

        window.onclick = function() {
            document.getElementById('exportMenu').classList.remove('show');
        };

        function toggleBlockList() {
            isListOpen = !isListOpen;
            const wrapper = document.getElementById('blockListWrapper');
            const arrow = document.getElementById('listArrow');
            wrapper.style.display = isListOpen ? 'block' : 'none';
            arrow.style.transform = isListOpen ? 'rotate(180deg)' : 'rotate(0deg)';
        }

        function changeLanguage(lang) {
            currentLang = lang;
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.getAttribute('data-i18n');
                el.innerText = translations[lang][key];
            });
            const modeBtn = document.getElementById('modeBtn');
            modeBtn.innerText = translations[lang].coordPrefix + translations[lang].coordModes[coordMode];
            const rotBtn = document.getElementById('rotateBtn');
            rotBtn.innerText = isAutoRotating ? translations[lang].stopRotateBtn : translations[lang].startRotateBtn;
        }

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x020617);
            const container = document.getElementById('container');
            camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                preserveDrawingBuffer: true 
            });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1.5);
            scene.add(hemiLight);
            const dLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dLight.position.set(10, 20, 10);
            scene.add(dLight);

            updateGridSize(21);
            scene.add(labelGroup);
            scene.add(blockGroup);

            const list = document.getElementById('availableBlocksList');
            Object.keys(MODELS).sort().forEach(id => {
                if(id === 'minecraft:air') return;
                const li = document.createElement('li');
                li.innerHTML = `‚Ä¢ <code class="bg-slate-700 px-1 rounded text-white">${id}</code>`;
                list.appendChild(li);
            });

            setupControls();
            changeLanguage('hu');
            animate();
            setTimeout(parseAndRunCommands, 500);
        }

        function updateGridSize(val) {
            currentGridSize = parseInt(val);
            document.getElementById('gridVal').innerText = currentGridSize;
            if (gridHelper) scene.remove(gridHelper);
            gridHelper = new THREE.GridHelper(currentGridSize, currentGridSize, 0x475569, 0x1e293b);
            scene.add(gridHelper);
            updateLabels();
        }

        function setupControls() {
            const container = document.getElementById('container');
            let isDragging = false;
            let dragButton = -1;
            container.addEventListener('contextmenu', e => e.preventDefault());
            container.addEventListener('mousedown', e => { isDragging = true; dragButton = e.button; });
            window.addEventListener('mouseup', () => { isDragging = false; dragButton = -1; });
            window.addEventListener('mousemove', e => {
                if (!isDragging) return;
                if (dragButton === 0) {
                    targetRotationY += e.movementX * 0.005;
                    targetRotationX += e.movementY * 0.005;
                    targetRotationX = Math.max(-Math.PI/2.1, Math.min(Math.PI/2.1, targetRotationX));
                } else if (dragButton === 2) {
                    const offset = new THREE.Vector3(-e.movementX * 0.03, e.movementY * 0.03, 0);
                    offset.applyQuaternion(camera.quaternion);
                    cameraTarget.add(offset);
                }
            });
            container.addEventListener('wheel', e => { e.preventDefault(); adjustZoom(e.deltaY * 0.05); }, { passive: false });
        }

        async function parseAndRunCommands() {
            const text = document.getElementById('commandEditor').value;
            const lines = text.split('\n');
            const loaderScreen = document.getElementById('loading-screen');
            const titleEl = document.getElementById('loading-title');
            const progressEl = document.getElementById('loading-progress');
            
            titleEl.innerText = translations[currentLang].loadingText;
            loaderScreen.style.display = 'flex';
            clearAllBlocks();
            worldData = {}; 

            for (let line of lines) {
                line = line.trim();
                if(!line) continue;

                const setblockMatch = line.match(/^\/setblock\s+(-?\d+)\s+(-?\d+)\s+(-?\d+)\s+([^\[\s]+)/);
                if (setblockMatch) {
                    const x = parseInt(setblockMatch[1]), y = parseInt(setblockMatch[2]), z = parseInt(setblockMatch[3]);
                    let blockId = setblockMatch[4].toLowerCase().trim();
                    if (!blockId.includes(':')) blockId = 'minecraft:' + blockId;
                    worldData[`${x},${y},${z}`] = { blockId };
                }
                
                const fillMatch = line.match(/^\/fill\s+(-?\d+)\s+(-?\d+)\s+(-?\d+)\s+(-?\d+)\s+(-?\d+)\s+(-?\d+)\s+([^\[\s]+)/);
                if (fillMatch) {
                    const x1 = parseInt(fillMatch[1]), y1 = parseInt(fillMatch[2]), z1 = parseInt(fillMatch[3]);
                    const x2 = parseInt(fillMatch[4]), y2 = parseInt(fillMatch[5]), z2 = parseInt(fillMatch[6]);
                    let blockId = fillMatch[7].toLowerCase().trim();
                    if (!blockId.includes(':')) blockId = 'minecraft:' + blockId;
                    for (let ix = Math.min(x1, x2); ix <= Math.max(x1, x2); ix++) {
                        for (let iy = Math.min(y1, y2); iy <= Math.max(y1, y2); iy++) {
                            for (let iz = Math.min(z1, z2); iz <= Math.max(z1, z2); iz++) {
                                worldData[`${ix},${iy},${iz}`] = { blockId };
                            }
                        }
                    }
                }

                const cloneMatch = line.match(/^\/clone\s+(-?\d+)\s+(-?\d+)\s+(-?\d+)\s+(-?\d+)\s+(-?\d+)\s+(-?\d+)\s+(-?\d+)\s+(-?\d+)\s+(-?\d+)(?:\s+(\w+))?(?:\s+(\w+))?(?:\s+([\w:]+))?/);
                if (cloneMatch) {
                    const x1 = parseInt(cloneMatch[1]), y1 = parseInt(cloneMatch[2]), z1 = parseInt(cloneMatch[3]);
                    const x2 = parseInt(cloneMatch[4]), y2 = parseInt(cloneMatch[5]), z2 = parseInt(cloneMatch[6]);
                    const dx = parseInt(cloneMatch[7]), dy = parseInt(cloneMatch[8]), dz = parseInt(cloneMatch[9]);
                    const maskMode = (cloneMatch[10] || 'replace').toLowerCase();
                    const filterBlock = cloneMatch[12] ? (cloneMatch[12].includes(':') ? cloneMatch[12] : 'minecraft:' + cloneMatch[12]) : null;

                    const minX = Math.min(x1, x2), maxX = Math.max(x1, x2);
                    const minY = Math.min(y1, y2), maxY = Math.max(y1, y2);
                    const minZ = Math.min(z1, z2), maxZ = Math.max(z1, z2);

                    const buffer = [];
                    for (let ix = minX; ix <= maxX; ix++) {
                        for (let iy = minY; iy <= maxY; iy++) {
                            for (let iz = minZ; iz <= maxZ; iz++) {
                                const sourceKey = `${ix},${iy},${iz}`;
                                const sourceBlock = worldData[sourceKey];
                                if (maskMode === 'masked' && (!sourceBlock || sourceBlock.blockId === 'minecraft:air')) continue;
                                if (maskMode === 'filtered' && filterBlock && (!sourceBlock || sourceBlock.blockId !== filterBlock)) continue;
                                buffer.push({ relX: ix - minX, relY: iy - minY, relZ: iz - minZ, data: sourceBlock || { blockId: 'minecraft:air' } });
                            }
                        }
                    }
                    buffer.forEach(item => {
                        const targetKey = `${dx + item.relX},${dy + item.relY},${dz + item.relZ}`;
                        if (item.data.blockId === 'minecraft:air') delete worldData[targetKey];
                        else worldData[targetKey] = item.data;
                    });
                }
            }

            const entries = Object.entries(worldData);
            let count = 0;
            for (const [key, val] of entries) {
                const [x, y, z] = key.split(',').map(Number);
                if (MODELS[val.blockId]) await placeBlock(x, y, z, val.blockId);
                count++;
                if (count % 25 === 0) {
                    progressEl.innerText = `${count} / ${entries.length}`;
                    await new Promise(r => setTimeout(r, 0));
                }
            }
            loaderScreen.style.display = 'none';
        }

        async function placeBlock(x, y, z, blockId) {
            return new Promise((resolve) => {
                const url = MODELS[blockId];
                if (!url) return resolve();
                const processModel = (gltf) => {
                    const model = gltf.scene.clone();
                    model.position.set(x, y + 0.5, z);
                    blockGroup.add(model);
                    resolve();
                };
                if (modelCache[blockId]) processModel(modelCache[blockId]);
                else loader.load(url, (gltf) => { modelCache[blockId] = gltf; processModel(gltf); }, undefined, resolve);
            });
        }

        function clearAllBlocks() { while(blockGroup.children.length > 0) blockGroup.remove(blockGroup.children[0]); worldData = {}; }

        function takeScreenshot() {
            renderer.render(scene, camera);
            const dataURL = renderer.domElement.toDataURL('image/png');
            const a = document.createElement('a');
            a.href = dataURL;
            a.download = "minecraft_screenshot.png";
            a.click();
        }

        async function recordVideo() {
            const loaderScreen = document.getElementById('loading-screen');
            const titleEl = document.getElementById('loading-title');
            const progressEl = document.getElementById('loading-progress');
            const dot = document.getElementById('recording-dot');

            titleEl.innerText = translations[currentLang].recordingText;
            progressEl.innerText = "0%";
            loaderScreen.style.display = 'flex';
            dot.style.display = 'block';

            const stream = renderer.domElement.captureStream(60);
            const recorder = new MediaRecorder(stream, { mimeType: 'video/webm' });
            const chunks = [];

            recorder.ondataavailable = e => chunks.push(e.data);
            recorder.onstop = () => {
                const blob = new Blob(chunks, { type: 'video/webm' });
                downloadBlob(blob, "minecraft_turnaround.webm");
                loaderScreen.style.display = 'none';
                dot.style.display = 'none';
            };

            const startAngle = targetRotationY;
            const duration = 5000;
            const start = performance.now();
            recorder.start();

            function updateRecord() {
                const now = performance.now();
                const p = (now - start) / duration;
                if (p < 1) {
                    targetRotationY = startAngle + (p * Math.PI * 2);
                    progressEl.innerText = Math.round(p * 100) + "%";
                    requestAnimationFrame(updateRecord);
                } else {
                    targetRotationY = startAngle;
                    recorder.stop();
                }
            }
            updateRecord();
        }

        function exportSchematic() {
            const coords = Object.keys(worldData).map(k => k.split(',').map(Number));
            if (coords.length === 0) return;

            const min = [Math.min(...coords.map(c => c[0])), Math.min(...coords.map(c => c[1])), Math.min(...coords.map(c => c[2]))];
            const max = [Math.max(...coords.map(c => c[0])), Math.max(...coords.map(c => c[1])), Math.max(...coords.map(c => c[2]))];
            const size = [max[0] - min[0] + 1, max[1] - min[1] + 1, max[2] - min[2] + 1];

            const palette = { "minecraft:air": 0 };
            let paletteIdx = 1;
            const blockData = new Int8Array(size[0] * size[1] * size[2]);

            for (let y = 0; y < size[1]; y++) {
                for (let z = 0; z < size[2]; z++) {
                    for (let x = 0; x < size[0]; x++) {
                        const block = worldData[`${x + min[0]},${y + min[1]},${z + min[2]}`];
                        const id = block ? block.blockId : "minecraft:air";
                        if (palette[id] === undefined) palette[id] = paletteIdx++;
                        blockData[x + z * size[0] + y * size[0] * size[2]] = palette[id];
                    }
                }
            }
            
            const blob = new Blob([JSON.stringify({size, palette, data: Array.from(blockData)})], {type: "application/json"});
            downloadBlob(blob, "minecraft_build.schem.json");
            
            // Show modal instead of alert
            document.getElementById('modal-text').innerText = translations[currentLang].alertSchem;
            document.getElementById('modal-overlay').style.display = 'flex';
        }

        function exportGLB() {
            const exporter = new THREE.GLTFExporter();
            exporter.parse(blockGroup, (result) => {
                const blob = new Blob([JSON.stringify(result)], {type: 'application/octet-stream'});
                downloadBlob(blob, "minecraft_model.glb");
            }, { binary: false });
        }

        function downloadBlob(blob, filename) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }

        function cycleCoordMode() {
            coordMode = (coordMode + 1) % 3;
            document.getElementById('modeBtn').innerText = translations[currentLang].coordPrefix + translations[currentLang].coordModes[coordMode];
            updateLabels();
        }

        function updateLabels() {
            while(labelGroup.children.length > 0) labelGroup.remove(labelGroup.children[0]);
            if (coordMode === 0) return;
            const halfSize = currentGridSize / 2;
            const matBlue = new THREE.LineBasicMaterial({ color: 0x3b82f6 }), matRed = new THREE.LineBasicMaterial({ color: 0xef4444 });
            labelGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(-halfSize, 0.05, 0), new THREE.Vector3(halfSize, 0.05, 0)]), matRed));
            labelGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0.05, -halfSize), new THREE.Vector3(0, 0.05, halfSize)]), matBlue));
            
            const step = currentGridSize > 50 ? 5 : 2;
            const limit = Math.floor(halfSize);
            for (let i = -limit; i <= limit; i++) {
                if (i === 0) { createLabel("0,0", 0.5, 0.2, 0.5, "#ffffff", 40); continue; }
                if (i % step === 0) {
                    createLabel(i.toString(), i, 0.2, 0, "#ef4444", 40);
                    createLabel(i.toString(), 0, 0.2, i, "#3b82f6", 40);
                }
            }
        }

        function createLabel(text, x, y, z, color, fontSize) {
            const canvas = document.createElement('canvas'); canvas.width = 128; canvas.height = 64;
            const ctx = canvas.getContext('2d'); ctx.fillStyle = color; ctx.font = `Bold ${fontSize}px Arial`; ctx.textAlign = 'center'; ctx.fillText(text, 64, 45);
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas), transparent: true }));
            sprite.position.set(x, y, z); sprite.scale.set(1.5, 0.75, 1);
            labelGroup.add(sprite);
        }

        function adjustZoom(amount) { zoomDistance = Math.max(2, Math.min(200, zoomDistance + amount)); }
        function toggleAutoRotate() { isAutoRotating = !isAutoRotating; changeLanguage(currentLang); }
        function resetCamera() { targetRotationX = 0.5; targetRotationY = -0.5; zoomDistance = 25; cameraTarget.set(0, 0, 0); }

        function animate() {
            requestAnimationFrame(animate);
            if (isAutoRotating) targetRotationY += 0.01;
            camera.position.set(cameraTarget.x + zoomDistance * Math.sin(targetRotationY) * Math.cos(targetRotationX), cameraTarget.y + zoomDistance * Math.sin(targetRotationX), cameraTarget.z + zoomDistance * Math.cos(targetRotationY) * Math.cos(targetRotationX));
            camera.lookAt(cameraTarget);
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            const container = document.getElementById('container');
            camera.aspect = container.clientWidth / container.clientHeight; camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        });

            init();
    </script>
</body>
</html>
